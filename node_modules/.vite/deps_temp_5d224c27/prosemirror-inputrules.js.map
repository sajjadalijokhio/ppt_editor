{
  "version": 3,
  "sources": ["../../prosemirror-inputrules/dist/index.js"],
  "sourcesContent": ["import { Plugin } from 'prosemirror-state';\nimport { findWrapping, canJoin } from 'prosemirror-transform';\n\n/**\nInput rules are regular expressions describing a piece of text\nthat, when typed, causes something to happen. This might be\nchanging two dashes into an emdash, wrapping a paragraph starting\nwith `\"> \"` into a blockquote, or something entirely different.\n*/\nclass InputRule {\n    // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number) → ?Transaction>)\n    /**\n    Create an input rule. The rule applies when the user typed\n    something and the text directly in front of the cursor matches\n    `match`, which should end with `$`.\n    \n    The `handler` can be a string, in which case the matched text, or\n    the first matched group in the regexp, is replaced by that\n    string.\n    \n    Or a it can be a function, which will be called with the match\n    array produced by\n    [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),\n    as well as the start and end of the matched range, and which can\n    return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the\n    rule's effect, or null to indicate the input was not handled.\n    */\n    constructor(\n    /**\n    @internal\n    */\n    match, handler, options = {}) {\n        this.match = match;\n        this.match = match;\n        this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler;\n        this.undoable = options.undoable !== false;\n    }\n}\nfunction stringHandler(string) {\n    return function (state, match, start, end) {\n        let insert = string;\n        if (match[1]) {\n            let offset = match[0].lastIndexOf(match[1]);\n            insert += match[0].slice(offset + match[1].length);\n            start += offset;\n            let cutOff = start - end;\n            if (cutOff > 0) {\n                insert = match[0].slice(offset - cutOff, offset) + insert;\n                start = end;\n            }\n        }\n        return state.tr.insertText(insert, start, end);\n    };\n}\nconst MAX_MATCH = 500;\n/**\nCreate an input rules plugin. When enabled, it will cause text\ninput that matches any of the given rules to trigger the rule's\naction.\n*/\nfunction inputRules({ rules }) {\n    let plugin = new Plugin({\n        state: {\n            init() { return null; },\n            apply(tr, prev) {\n                let stored = tr.getMeta(this);\n                if (stored)\n                    return stored;\n                return tr.selectionSet || tr.docChanged ? null : prev;\n            }\n        },\n        props: {\n            handleTextInput(view, from, to, text) {\n                return run(view, from, to, text, rules, plugin);\n            },\n            handleDOMEvents: {\n                compositionend: (view) => {\n                    setTimeout(() => {\n                        let { $cursor } = view.state.selection;\n                        if ($cursor)\n                            run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin);\n                    });\n                }\n            }\n        },\n        isInputRules: true\n    });\n    return plugin;\n}\nfunction run(view, from, to, text, rules, plugin) {\n    if (view.composing)\n        return false;\n    let state = view.state, $from = state.doc.resolve(from);\n    if ($from.parent.type.spec.code)\n        return false;\n    let textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, \"\\ufffc\") + text;\n    for (let i = 0; i < rules.length; i++) {\n        let rule = rules[i], match = rule.match.exec(textBefore);\n        let tr = match && rule.handler(state, match, from - (match[0].length - text.length), to);\n        if (!tr)\n            continue;\n        if (rule.undoable)\n            tr.setMeta(plugin, { transform: tr, from, to, text });\n        view.dispatch(tr);\n        return true;\n    }\n    return false;\n}\n/**\nThis is a command that will undo an input rule, if applying such a\nrule was the last thing that the user did.\n*/\nconst undoInputRule = (state, dispatch) => {\n    let plugins = state.plugins;\n    for (let i = 0; i < plugins.length; i++) {\n        let plugin = plugins[i], undoable;\n        if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n            if (dispatch) {\n                let tr = state.tr, toUndo = undoable.transform;\n                for (let j = toUndo.steps.length - 1; j >= 0; j--)\n                    tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n                if (undoable.text) {\n                    let marks = tr.doc.resolve(undoable.from).marks();\n                    tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n                }\n                else {\n                    tr.delete(undoable.from, undoable.to);\n                }\n                dispatch(tr);\n            }\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\nConverts double dashes to an emdash.\n*/\nconst emDash = new InputRule(/--$/, \"—\");\n/**\nConverts three dots to an ellipsis character.\n*/\nconst ellipsis = new InputRule(/\\.\\.\\.$/, \"…\");\n/**\n“Smart” opening double quotes.\n*/\nconst openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\");\n/**\n“Smart” closing double quotes.\n*/\nconst closeDoubleQuote = new InputRule(/\"$/, \"”\");\n/**\n“Smart” opening single quotes.\n*/\nconst openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\");\n/**\n“Smart” closing single quotes.\n*/\nconst closeSingleQuote = new InputRule(/'$/, \"’\");\n/**\nSmart-quote related input rules.\n*/\nconst smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];\n\n/**\nBuild an input rule for automatically wrapping a textblock when a\ngiven string is typed. The `regexp` argument is\ndirectly passed through to the `InputRule` constructor. You'll\nprobably want the regexp to start with `^`, so that the pattern can\nonly occur at the start of a textblock.\n\n`nodeType` is the type of node to wrap in. If it needs attributes,\nyou can either pass them directly, or pass a function that will\ncompute them from the regular expression match.\n\nBy default, if there's a node with the same type above the newly\nwrapped node, the rule will try to [join](https://prosemirror.net/docs/ref/#transform.Transform.join) those\ntwo nodes. You can pass a join predicate, which takes a regular\nexpression match and the node before the wrapped node, and can\nreturn a boolean to indicate whether a join should happen.\n*/\nfunction wrappingInputRule(regexp, nodeType, getAttrs = null, joinPredicate) {\n    return new InputRule(regexp, (state, match, start, end) => {\n        let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n        let tr = state.tr.delete(start, end);\n        let $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && findWrapping(range, nodeType, attrs);\n        if (!wrapping)\n            return null;\n        tr.wrap(range, wrapping);\n        let before = tr.doc.resolve(start - 1).nodeBefore;\n        if (before && before.type == nodeType && canJoin(tr.doc, start - 1) &&\n            (!joinPredicate || joinPredicate(match, before)))\n            tr.join(start - 1);\n        return tr;\n    });\n}\n/**\nBuild an input rule that changes the type of a textblock when the\nmatched text is typed into it. You'll usually want to start your\nregexp with `^` to that it is only matched at the start of a\ntextblock. The optional `getAttrs` parameter can be used to compute\nthe new node's attributes, and works the same as in the\n`wrappingInputRule` function.\n*/\nfunction textblockTypeInputRule(regexp, nodeType, getAttrs = null) {\n    return new InputRule(regexp, (state, match, start, end) => {\n        let $start = state.doc.resolve(start);\n        let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n        if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType))\n            return null;\n        return state.tr\n            .delete(start, end)\n            .setBlockType(start, start, nodeType, attrs);\n    });\n}\n\nexport { InputRule, closeDoubleQuote, closeSingleQuote, ellipsis, emDash, inputRules, openDoubleQuote, openSingleQuote, smartQuotes, textblockTypeInputRule, undoInputRule, wrappingInputRule };\n"],
  "mappings": "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",
  "names": []
}
